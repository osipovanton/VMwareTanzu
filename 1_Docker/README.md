# Основы контейнеров
## Что такое Контейнеры?
Контейнеры — это упрощенная форма виртуализации на уровне ОС. Они позволяют запускать набор процессов приложений в их собственной изолированной среде без необходимости запуска полной операционной системы.

Важно отметить, что виртуальные машины и контейнеры не исключают друг друга. Инфраструктурой (сетями, серверами и хранилищем), необходимой для поддержки контейнеров, часто легче управлять с помощью виртуализации, поэтому эти две технологии дополняют друг друга.

Как правило, термин контейнер используется для обозначения либо образа контейнера, либо экземпляра работающего контейнера. Когда вы запускаете контейнер, уровень абстракции, среда выполнения контейнера, планирует доступ к общей операционной системе. Стандарты контейнеров разрабатываются инициативой [Open Container Initiative](https://opencontainers.org/), которая в настоящее время имеет спецификации как для среды выполнения контейнера, так и для образа контейнера.


## Среда выполнения контейнера

Хотя Docker является наиболее популярным примером среды выполнения контейнера, существуют и другие, такие как containerd, rkt и т. д.


Подобно тому, как ядро Linux помогает запускать процессы приложений, предоставляя аппаратные ресурсы, среда выполнения контейнера помогает разделить ядро Linux для запуска изолированных процессов Linux с определенными ограничениями ресурсов для ЦП, памяти и т. д. Среда выполнения также помогает изолировать процессы приложений, используя два ядра Linux. примитивы: [контрольные группы (cgroups)](https://man7.org/linux/man-pages/man7/cgroups.7.html) и [пространства имен](https://man7.org/linux/man-pages/man7/namespaces.7.html). Cgroups ограничивают ресурсы набором процессов, работающих на хосте Linux, а пространства имен изолируют процессы друг от друга.


![image](https://user-images.githubusercontent.com/79700810/196975434-bc0a0a42-e183-4af4-a701-3b063ceab4a4.png)

Работающий контейнер — это набор процессов (обычно приложение), которые поддерживает среда выполнения контейнера, обеспечивая создание необходимых конструкций в ядре для ограничения потребления ресурсов и обеспечения изоляции.

![image](https://user-images.githubusercontent.com/79700810/196975523-a735587c-182e-49e1-ac26-1a4f3edaff7a.png)

## Как помогают контейнеры?
Поскольку контейнеры работают на более высоком уровне абстракции, чем виртуальные машины, они улучшают переносимость приложений, эластичность сервера и использование ресурсов сервера. Среда выполнения контейнера может планировать работу нескольких контейнеров в общей операционной системе, что выгодно как операторам инфраструктуры, так и разработчикам приложений.

Преимущества для операционных, инфраструктурных и ИТ-команд

1. Снижает размер операционной системы, которой необходимо управлять на серверах.

2. Снижает зависимость приложения от операционной системы

3. Облегчает техническое обслуживание и сокращает периоды обслуживания


Преимущества для команд разработки приложений

1. Поскольку контейнеры отделяют приложение и его зависимости от операционной системы, команды разработчиков могут не создавать несколько тестовых сред с различными операционными системами для проверки поведения приложения.

2. Оптимизирует конвейер разработки, чтобы сократить время создания и доставки приложений.

Все эти преимущества дают убедительный результат: контейнеры сокращают время, необходимое для создания, тестирования и доставки приложений.

Контейнеры помогают ускорить конвейеры разработки, оптимизируя циклы разработки/тестирования и сокращая усилия, необходимые для развертывания приложений. Они последовательно выполняются в каждом развертывании, обеспечивая переносимость между платформами и между облаками. Контейнеры повышают эффективность и гибкость организации.

## Что такое подсистема Windows для Linux?

Подсистема Windows для Linux позволяет разработчикам запускать среду GNU/Linux, включая большинство инструментов, утилит и приложений командной строки, непосредственно в Windows, без изменений, без накладных расходов, связанных с традиционной виртуальной машиной или двойной загрузкой.

![image](https://user-images.githubusercontent.com/79700810/197137387-cbcb947b-c538-4592-840a-45d58ca29626.png)

### Установка WSL

```powershell
wsl --list --online
```

![image](https://user-images.githubusercontent.com/79700810/197135769-23c61728-cd98-4668-b4dc-c66c027f59b8.png)

```powershell
wsl --install -d Ubuntu-20.04
```

![image](https://user-images.githubusercontent.com/79700810/197136903-f91333e0-a798-43bd-8a65-e3b60eb453ce.png)

После перезагрузки запускается консоль для конфигурации WSL

![image](https://user-images.githubusercontent.com/79700810/197138559-da84f76f-7ce7-4c68-ae1e-44a8d23f24f9.png)


### Установка Docker в WSL

```
sudo -i
apt-get update
apt-get install -y ca-certificates curl gnupg lsb-release
```

![image](https://user-images.githubusercontent.com/79700810/196971710-b2e502cf-285a-42b1-8a83-ba462fe037aa.png)

```
mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
```
```
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```
```
apt-get update
apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
```

![image](https://user-images.githubusercontent.com/79700810/196971959-4b2a40e3-5803-4ada-91eb-62b4fe15e5d5.png)

```
service docker start
```

![image](https://user-images.githubusercontent.com/79700810/196972322-82cf36d4-ad0c-4f89-ac51-770f1b4ed6f3.png)


### Запуск контейнера


Чтобы запустить приложение внутри контейнера с помощью докера, вам нужно иметь образ контейнера. Образ контейнера действует как механизм упаковки для распространения приложения и включает в себя программное обеспечение приложения, файлы операционной системы, библиотеки и другое программное обеспечение, необходимое приложению для запуска.


Готовые образы контейнеров для приложений или базовый образ контейнера, на основе которого вы можете создать собственный образ контейнера, распространяются с помощью image registries.

Двумя основными существующими image registries размещенных образов являются [Docker Hub](https://hub.docker.com/) и [Quay.io](https://quay.io/). Поддержка размещения и распространения образов контейнеров также доступна в службах размещения репозиториев Git, таких как [GitHub](https://github.com/) и [GitLab](https://about.gitlab.com/).

Чтобы извлечь и запустить существующий образ контейнера из реестра образов с помощью docker run:

```docker
docker run docker.io/busybox:latest date
```


Окончательный вывод должен быть похож на:


![image](https://user-images.githubusercontent.com/79700810/197143064-b5f0954e-9c01-44c1-9e22-b0aa853cf92f.png)



Команда регистрирует сведения о шагах, предпринятых для передачи образа в локальную среду. После завершения этого процесса из образа контейнера запускается контейнер, и внутри контейнера запускается команда date, указанная в командной строке. Поскольку команда date завершается немедленно, контейнер сразу же выключается.

В этом случае образ контейнера, который использовался, назывался busybox. Это очень минимальный образ Unix-подобного контейнера. Мы указали, что будет использоваться latest последняя версия образа контейнера и что он должен быть извлечен из реестра образов Docker Hub (docker.io).


Если вы запустите команду второй раз:


```docker
docker run docker.io/busybox:latest date
```

вы увидите, что он немедленно выполняет команду date и не регистрирует никаких подробностей о необходимости сначала извлечь образ контейнера. Это связано с тем, что образ контейнера был кэширован в локальной среде и будет использоваться при последующих запусках.

![image](https://user-images.githubusercontent.com/79700810/197143721-405c3032-cf3e-43cf-9e5a-c1b9b75df357.png)

Вы можете увидеть, какие образы контейнеров были загружены в локальную среду, выполнив:

```docker
docker images
```

Это должно выводить детали, подобные:

![image](https://user-images.githubusercontent.com/79700810/197143886-aceb5f6a-611a-4dad-a0ca-10f75bc3c144.png)


При необходимости docker run загрузит образ контейнера в первый раз, когда это потребуется. Если вы хотите извлечь образы до их запуска, вы можете использовать команду docker pull

```docker
docker pull docker.io/busybox:latest
```

![image](https://user-images.githubusercontent.com/79700810/197144173-362265d7-d820-43d7-82df-f4b7f4468416.png)


### Интерактивный терминал


В предыдущем упражнении вы выполнили команду date в контейнере, запущенном из образа контейнера busybox. Вы можете выполнить любое приложение, включенное в образ контейнера.


Если вы хотите создать контейнер и взаимодействовать с ним для запуска в нем команд, вы можете запустить интерактивную оболочку.


```docker
docker run -it busybox sh
```

![image](https://user-images.githubusercontent.com/79700810/197144498-feec035d-d74b-4227-abb9-8eee8aa3747a.png)

При запуске команды, для которой требуется интерактивный терминал, вам необходимо указать параметры -it для запуска docker. Это приводит к выделению терминала, а стандартный ввод остается открытым для ввода.


В этом случае мы также сократили имя образа контейнера до busybox. Если тег версии не указан, будет использоваться последняя версия. Если хост реестра образов не используется, будет выполняться поиск в реестрах образов по умолчанию, определенных в глобальной конфигурации Docker. Поскольку мы уже получили образ busybox:latest из Docker Hub, он будет совпадать.


Чтобы увидеть список процессов, запущенных внутри контейнера, запустите:

```
ps
```
Вы должны увидеть вывод, похожий на:

![image](https://user-images.githubusercontent.com/79700810/197144808-5ec8e1fc-bb20-4330-b24f-b8559dc99b75.png)

Будут видны только процессы, запущенные в контексте контейнера. Процессы, запущенные на базовом узле контейнера, не видны.


Чтобы увидеть список запущенных контейнеров, вы можете запустить на хосте контейнера:

Примечание:
Необходимо открыть еще одну сессию к WSL

```docker
docker ps
```

Вы должны увидеть контейнер, который вы запустили выше, работающий с интерактивной оболочкой.

![image](https://user-images.githubusercontent.com/79700810/197145454-badaaadf-9aee-47ec-bbd4-28884b2a11e9.png)


Чтобы получить доступ к существующему контейнеру с хоста контейнера и запустить в нем команду, вы можете использовать команду docker exec. Как и в случае с docker run, при запуске команды, для которой требуется интерактивный терминал, используйте параметры -it.

При запуске docker exec вам необходимо указать идентификатор контейнера, к которому вы хотите получить доступ. Чтобы просмотреть идентификатор контейнера для самого последнего контейнера, который был запущен, вы можете запустить команду:

```docker
docker ps -ql
```

![image](https://user-images.githubusercontent.com/79700810/197146143-b61551c5-fdb1-4b75-8494-d8e704e2d2bd.png)


Чтобы создать второй интерактивный терминал, работающий в существующем контейнере, вы можете запустить:

```docker
docker exec -it `docker ps -ql` sh
```

![image](https://user-images.githubusercontent.com/79700810/197146282-8616d009-1b29-4d94-940e-51664bc9fdc1.png)


Снова запустите ps в исходном интерактивном терминале:


```
ps
```

![image](https://user-images.githubusercontent.com/79700810/197146497-74000a69-410a-4265-8643-62b0ab73841e.png)


Теперь вы должны увидеть два запущенных процесса оболочки.

Выйдите из первого интерактивного терминала, выполнив:

```
exit
```

![image](https://user-images.githubusercontent.com/79700810/197146622-1af71cd3-ce36-4f89-aa44-3312ffc1c513.png)


Поскольку это был основной процесс, запущенный в контейнере с идентификатором процесса 1, контейнер будет остановлен, что приведет к закрытию второго сеанса интерактивного терминала.



### Остановленные контейнеры


Когда контейнеры выключаются, процессы приложения исчезают, но сохраняется копия состояния контейнера. Вы можете увидеть список всех контейнеров, включая остановленные контейнеры, запустив:


```docker
docker ps -a
```

Поскольку мы запустили несколько контейнеров, вы должны увидеть в списке несколько остановленных контейнеров.

![image](https://user-images.githubusercontent.com/79700810/197147003-fd0d86ce-6687-468d-9178-57d3b812be33.png)


Когда мы запускали контейнеры, мы запускали их на переднем плане, при этом любой вывод из контейнеров отображался в терминале.


Вывод из контейнера также записывался в файл журнала. Вы можете просмотреть файл журнала для контейнера, запущенного или остановленного, запустив команду docker logs с идентификатором контейнера в качестве аргумента.

```docker
docker logs `docker ps -ql`
```

![image](https://user-images.githubusercontent.com/79700810/197147326-96ff1546-1514-4175-a6ca-a8efec2d5f1f.png)

В дополнение к файлу журнала для контейнера также сохраняется копия изменений, внесенных в файловую систему из контейнера. Можно скопировать файлы из остановленного контейнера или создать новый образ контейнера из остановленного контейнера.

Хотя остановленные контейнеры можно использовать в некоторых случаях, они занимают место, поэтому важно удалять остановленные контейнеры. Если вы этого не сделаете, в конечном итоге у вас закончится место на диске.

Чтобы удалить один остановленный контейнер, вы можете использовать docker rm с идентификатором контейнера в качестве аргумента.

```docker
docker rm `docker ps -ql`
```

![image](https://user-images.githubusercontent.com/79700810/197147688-0245b639-cc5c-40c9-a72e-33ec9aec35c8.png)


Теперь у вас должны остаться только два остановленных контейнера.

```docker
docker ps -a
```

![image](https://user-images.githubusercontent.com/79700810/197147859-a451c055-4773-4c77-bc51-202fa8d873da.png)


Чтобы удалить все остановленные контейнеры, запустите:

```docker
docker rm $(docker ps -aq)
```

![image](https://user-images.githubusercontent.com/79700810/197148006-21ec802e-6ec0-432c-b2bc-d8b86e26dc68.png)


Хотя docker ps -a будет отвечать запущенными контейнерами, а также остановленными контейнерами, команда docker rm удалит только остановленные контейнеры.


Теперь не должно быть оставшихся контейнеров.

```docker
docker ps -a
```


![image](https://user-images.githubusercontent.com/79700810/197148277-773bc21f-c3eb-42aa-a522-74abb07c8855.png)


Если вы знаете, что вам не нужно взаимодействовать с остановленным контейнером после его завершения, вы можете использовать параметр --rm при запуске docker run.

```docker
docker run --rm busybox date
```

![image](https://user-images.githubusercontent.com/79700810/197148439-01c444a5-6983-48f1-96de-bcbcac25d9f3.png)



С этой опцией остановленный контейнер будет автоматически удален.
```docker
docker ps -a
```

![image](https://user-images.githubusercontent.com/79700810/197148584-fd600786-d9a8-48f5-b38e-911b5b066132.png)



### Сетевые службы


Все контейнеры, которые вы запускали до сих пор, оставались привязанными к терминалу, с которого они были запущены. Вывод из контейнера отображался на терминале, и вы возвращали командную строку только тогда, когда контейнер был остановлен.


Долгоживущие сетевые службы, работающие в контейнере, необходимо будет отсоединить от терминала и запустить как фоновый процесс.

Чтобы запустить веб-сервер с помощью образа busybox, запустите:

```docker
docker run --rm -d --name httpd -p 8080:80 busybox httpd -f -vv
```


![image](https://user-images.githubusercontent.com/79700810/197148907-36605e27-d81a-4733-a11e-a3e2b95d0931.png)


Параметр -d для запуска docker приводит к тому, что контейнер отсоединяется от терминала и запускается в фоновом режиме.

Чтобы упростить идентификацию контейнера и взаимодействие с ним, мы используем параметр --name, чтобы дать ему имя httpd.

Поскольку веб-сервер является сетевой службой, нам необходимо указать сетевые порты, которые он предоставляет. Это делается с помощью опции -p.


Наконец, для запуска команды в контейнере мы используем httpd -f -vv.


Параметр -f для httpd гарантирует, что веб-сервер работает как процесс переднего плана в контексте контейнера. Если этого не сделать, контейнер немедленно выйдет. -vv включает подробное ведение журнала

Чтобы убедиться, что контейнер запущен, запустите:

```docker
docker ps
```

![image](https://user-images.githubusercontent.com/79700810/197149525-cc901e82-5479-43ff-ae83-c46631faac2e.png)


Чтобы завершить вывод из контейнера, запустите:


```docker
docker logs -f httpd
```

![image](https://user-images.githubusercontent.com/79700810/197149981-608504d3-7241-4fff-874b-b8a6b91b8f5d.png)


Вместо идентификатора контейнера мы используем имя httpd, которое мы присвоили контейнеру. Параметр -f говорит о постоянном хранении файлов журналов.

Первоначально не будет вывода журнала, но сделайте веб-запрос к веб-серверу, выполнив:
Примечание: Необходимо открыть еще одну сессию к WSL

```
curl localhost:8080
```

и вы должны увидеть детали зарегистрированного запроса.

![image](https://user-images.githubusercontent.com/79700810/197150418-3d05eb78-6676-47ad-8824-0b3c2515daaa.png)

В этом случае мы получаем ошибку от веб-сервера, поскольку мы не предоставили ему никаких файлов для обслуживания.
Поскольку контейнер был отсоединен от терминала, чтобы остановить контейнер, вам нужно запустить


![image](https://user-images.githubusercontent.com/79700810/197150699-7bcf3967-fbf9-401e-8960-ac5f475f94a0.png)



### Что такое Images

Вы создали работающий контейнер из образа контейнера. Образ контейнера, который вы использовали, был извлечен из реестра образов. Хотя существует множество образов контейнеров для часто используемых программных приложений, более вероятно, что вы захотите создать образ контейнера для своего собственного приложения.

Образ контейнера ранее описывался как механизм упаковки для распространения приложения, включая прикладное программное обеспечение, файлы операционной системы, библиотеки и другое программное обеспечение, необходимое приложению для запуска.

В этом смысле образ контейнера можно рассматривать как причудливую форму архива или zip-файла, который распаковывается для заполнения файловой системы. Хотя это немного сложнее, чем это.


Образ контейнера представляет собой не единый пакет, содержащий все необходимые файлы, а набор пакетов, каждый из которых содержит файлы из одного слоя образа контейнера.

![image](https://user-images.githubusercontent.com/79700810/197151084-62d6ebf2-0dfc-4521-a34b-e0d18417c38d.png)



Каждый образ контейнера начинается с base layer базового слоя. Обычно это будут все файлы базовой операционной системы, приложения и библиотеки.
Поверх этого добавляются дополнительные слои. В каждом слое вы можете добавить больше файлов, изменить существующие файлы или удалить файлы.

Когда существующие файлы изменяются или удаляются, изменяется не исходный файл на нижнем уровне. Вместо этого для модификации новая копия файла с изменениями существует на новом уровне, а оригинал на нижнем уровне все еще существует, как и был. В случае удаления файла метаданные слоя записывают, что файл был удален на этом уровне, а оригинал все еще существует на нижнем уровне.

Изменения или удаления обрабатываются таким образом, потому что каждый слой неизменен. Единственный способ повлиять на изменение — создать новый слой.

Когда образ контейнера используется при создании контейнера, используется специальный тип файловой системы, который накладывает каждый слой из образа контейнера друг на друга, чтобы сформировать составное представление слоев.


![image](https://user-images.githubusercontent.com/79700810/197151534-4b881ede-9994-46bd-b231-db2249c51366.png)

Этот окончательный составной вид сам по себе по-прежнему доступен только для чтения. Для изменений, внесенных в файлы внутри контейнера, они будут существовать в еще одном слое, который существует на протяжении всего срока службы контейнера.



Фактическая спецификация формата образа контейнера определяется [OCI Image Format Specification](https://github.com/opencontainers/image-spec). То, как образ распаковывается, интерпретируется и используется для запуска приложения в контейнере, определяется [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec). Обе спецификации находятся под управлением [Open Container Initiative](https://opencontainers.org/), организации, спонсируемой Linux Foundation.


### Создание образа


Существует три основных способа создания образа контейнера. Это:

1. Интерактивное построение образа путем запуска контейнера с использованием существующего образа, внесения изменений в контейнер и сохранения результата в виде нового образа контейнера.
2. Создание образа контейнера в виде пакетного процесса с использованием набора скриптовых инструкций во входном файле. Каноническим примером этого является использование Dockerfile для создания образа контейнера.
3. Создание образа контейнера путем импорта копии файловой системы из архива.

На этом семинаре мы рассмотрим первые два описанных выше метода.


### Image Контейнер

Первый способ создания образа контейнера — запустить контейнер с использованием существующего образа контейнера, выполнить все необходимые шаги для установки или копирования файлов в контейнер и сохранить результат как новый образ контейнера.

Чтобы проиллюстрировать этот метод, сначала запустите экземпляр контейнера busybox с интерактивной оболочкой.

```docker
docker run -it --name session busybox sh
```
![image](https://user-images.githubusercontent.com/79700810/197153312-fe909e9a-66cf-4152-ad54-3469e3b217b5.png)


Теперь вы должны запустить любые команды для установки дополнительных пакетов. В случае образа контейнера busybox он не предоставляет диспетчера пакетов, поэтому мы ограничимся созданием исполняемого файла сценария, который мы можем запустить. Чтобы создать файл сценария, выполните:

```
cat > hello << EOF
#!/bin/sh
echo "Hello"
EOF
```

![image](https://user-images.githubusercontent.com/79700810/197172932-da50f861-3acc-4b0b-9794-292acfc4108b.png)




Сделать исполняемый файл скрипта

```
chmod +x hello
```

![image](https://user-images.githubusercontent.com/79700810/197173068-baf1c97b-2717-46d8-a9d1-61299a3b3c52.png)


В этом случае мы создаем файл сценария, запустив команду внутри контейнера. Альтернативой является копирование файла скрипта в контейнер с локального хоста.


Создайте файл на локальном хосте, запустив:

Примечание: Необходимо открыть еще одну сессию к WSL

```
cat > goodbye << EOF
#!/bin/sh
echo "Goodbye"
EOF
```

![image](https://user-images.githubusercontent.com/79700810/197173121-5a1ebc3f-04e0-4fda-a7ed-48cafbafa3ca.png)

Также сделайте его исполняемым:

```
chmod +x goodbye
```

![image](https://user-images.githubusercontent.com/79700810/197173197-ef99b6e5-bc39-457f-95ff-7fd603cdeb56.png).


Скопируйте этот файл сценария в контейнер, выполнив:

```docker
docker cp goodbye session:/goodbye
```

![image](https://user-images.githubusercontent.com/79700810/197173275-2db35753-c9b8-44ac-9976-9bc904d859da.png)


Поскольку мы назвали контейнер именем session, мы могли использовать его в качестве цели, куда следует скопировать файл. Если бы вы не назвали контейнер, вам нужно было бы использовать идентификатор контейнера.


Убедитесь, что вы видите оба файла из контейнера.

```
ls -las
```

![image](https://user-images.githubusercontent.com/79700810/197173326-29c99024-1cb6-4298-aa0e-a3629aa6411f.png)


Теперь выйдите из контейнера, запустив:

```
exit
```

В этот момент контейнер был остановлен, так как мы вышли из процесса интерактивной оболочки, который поддерживал его работу. Вы можете увидеть, что он остановился, запустив:

```docker
docker ps -a
```


![image](https://user-images.githubusercontent.com/79700810/197156495-795e2d45-25b5-4656-a40a-871f3732ad7b.png)



Хотя он был остановлен, поскольку мы не использовали параметр --rm при запуске docker, состояние контейнера было сохранено, включая изменения, которые мы внесли в файловую систему изнутри контейнера.


Чтобы создать образ контейнера из сохраненного состояния контейнера, запустите:

```docker
docker commit --change='CMD ["/hello"]' session greeting
```

![image](https://user-images.githubusercontent.com/79700810/197173470-59a20c3d-81ca-4c7f-a5c7-bc35edd86ea2.png)


Название образа контейнера, который вы создали, было greeting. Чтобы просмотреть сведения об образе контейнера, запустите:

```docker
docker images
```

![image](https://user-images.githubusercontent.com/79700810/197157147-73069a34-8a0c-458b-aa1d-a2f74e35c05e.png)

Чтобы запустить образ контейнера, запустите:

```docker
docker run --rm greeting
```

![image](https://user-images.githubusercontent.com/79700810/197174205-a58396e7-67ed-4e44-80b2-54857d6b5779.png)


Вы могли запустить образ контейнера, не указывая, какую команду запускать в контейнере, поскольку параметр --change, используемый с фиксацией Docker выше, переопределяет команду по умолчанию, запускаемую при запуске образа контейнера.

При необходимости вы по-прежнему можете запустить образ контейнера с помощью альтернативной команды.

```docker
docker run --rm greeting /goodbye
```

![image](https://user-images.githubusercontent.com/79700810/197174468-43bd11ae-83ca-401b-9705-6f556c51b869.png)



### Проверка слоев 


Чтобы проверить слои образа контейнера, который вы только что создали, запустите:

```docker
docker history greeting
```

![image](https://user-images.githubusercontent.com/79700810/197174953-fd0568a3-e714-4bff-852c-492562a76a36.png)


Верхний уровень зафиксировал изменения, внесенные вами в сеансе интерактивной оболочки работающего контейнера. Остальные слои были унаследованы от образа контейнера busybox.

Поскольку вы создали образ контейнера из работающего контейнера, невозможно увидеть, какие отдельные команды вы выполнили или какие файлы скопировали в контейнер.


Чтобы увидеть метаданные для образа контейнера, вы также можете запустить:


```docker
docker inspect greeting
```



![image](https://user-images.githubusercontent.com/79700810/197175193-14b0bb8e-621e-4b9a-8176-51daf26fd93d.png)


Сюда входят сведения о слоях, а также информация о команде, запускаемой при запуске образа контейнера, и сведения о любых переменных среды, установленных образом контейнера.


### Использование Dockerfile

Интерактивное создание образа контейнера путем запуска команд в работающем контейнере или из tar-архива, созданного из сохраненного образа контейнера, имеет свои применения, но основной способ создания образов контейнера — использование Dockerfile.



Измените местоположение на подкаталог 

```
mkdir /appHello
chmod +x -R /appHello
```

![image](https://user-images.githubusercontent.com/79700810/197196284-6777bea0-b746-4f3f-8494-7f0a249be3b9.png)

Dockerfile определяет детали базового образа, из которого должен быть создан новый образ контейнера, а также инструкции по его созданию. Просмотрите содержимое Dockerfile, запустив:

```
vim /appHello/Dockerfile
```

```
FROM busybox:latest
COPY hello goodbye /
CMD [ "/hello" ]
```

![image](https://user-images.githubusercontent.com/79700810/197184552-a98876e5-a44c-427f-8e68-f635e876f207.png)



Инструкция FROM в Dockerfile дает имя базового образа.

Инструкция COPY используется для копирования файлов из локального каталога в образ.
Примечание: данные файлы должны быть созданные в этой директории и назначены права


```
cat > hello << EOF
#!/bin/sh
echo "hello"
EOF

cat > goodbye << EOF
#!/bin/sh
echo "goodbye"
EOF

chmod +x -R /appHello

ls
```

![image](https://user-images.githubusercontent.com/79700810/197188595-91b4ba8c-fcdd-4333-a218-0e45f8f33bcb.png)



Инструкция CMD используется для установки команды, которая должна быть запущена, если образ контейнера запускается без указания явной команды.



Чтобы создать образ контейнера, используя инструкции в Dockerfile, выполните:

```docker
docker build -t greeting .
```

![image](https://user-images.githubusercontent.com/79700810/197187972-7fcddcca-7a46-4c77-987c-7a3f66ac3c06.png)


Посмотрите на слои образа контейнера, запустив:

![image](https://user-images.githubusercontent.com/79700810/197188152-fb71d1d9-6e3d-4e56-922c-deeefc5d8198.png)


Вы можете видеть, что в образе контейнера был создан слой для операторов COPY и CMD из нашего Dockerfile.


Чтобы запустить образ контейнера, запустите:

```docker
docker run --rm greeting
```

![image](https://user-images.githubusercontent.com/79700810/197188788-2c02adda-8eae-454a-a1a6-4565cd2adb89.png)

Или для запуска альтернативной команды используйте:

```docker
docker run --rm greeting /goodbye
```


![image](https://user-images.githubusercontent.com/79700810/197188884-ef3d878e-bea3-40c2-bb37-0c7c2f003448.png)


Полный список инструкций, которые вы можете использовать в файле Docker, см. в справочнике по [Dockerfile reference](https://docs.docker.com/engine/reference/builder/)..



### Выбор Base


В примерах до сих пор мы использовали image контейнера busybox. Это изображение удобно для демонстрации, потому что оно маленькое, но для реальных приложений оно не совсем подходит.

Для реальных приложений вам понадобится более полный базовый образ, созданный на основе одного из наиболее популярных дистрибутивов Linux.


Популярные варианты базовых изображений:


1. Fedora
2. CentOS
3. Debian
4. Ubuntu
5. Alpine

В оставшейся части этого семинара мы будем использовать базовый образ Fedora.

Удалите изображение приветствия, созданное из изображения busybox.

```docker
docker rmi greeting
```


![image](https://user-images.githubusercontent.com/79700810/197195049-5bdf2d43-10dd-475c-a7fe-bdf2db22b84b.png)


Измените местоположение на подкаталог 


```
mkdir /appHelloFedora
chmod +x -R /appHelloFedora
```

![image](https://user-images.githubusercontent.com/79700810/197195554-4e9963ac-4ee8-4827-bca0-ef98f5dd2b4d.png)


Просмотрите содержимое Dockerfile:

```
FROM fedora:35
COPY hello goodbye /
CMD [ "/hello" ]
```

![image](https://user-images.githubusercontent.com/79700810/197197260-500e1d5e-ece8-4640-a215-a46f321965c9.png)


Изменена только инструкция FROM. На этот раз вместо образа busybox используется базовый образ fedora:35.

Примечание: данные файлы должны быть созданные в этой директории и назначены права


```
cat > hello << EOF
#!/bin/sh
echo "hello"
EOF

cat > goodbye << EOF
#!/bin/sh
echo "goodbye"
EOF

chmod +x -R /appHelloFedora

ls
```


![image](https://user-images.githubusercontent.com/79700810/197197774-6960b641-0f9c-4dd1-8806-95387e1894b7.png)


Создайте образ, запустив:

```docker
docker build -t greeting .
```


![image](https://user-images.githubusercontent.com/79700810/197198007-85bfe773-228b-4284-a898-f3a4016d947a.png)


Сборка может занять немного больше времени, так как базовый образ Fedora необходимо удалить, и он несколько больше, чем более минимальный базовый образ busybox.



Когда сборка завершится, убедитесь, что образ контейнера запускается:

```docker
docker run --rm greeting
```

![image](https://user-images.githubusercontent.com/79700810/197198231-c042753b-9eea-4e00-a752-8db589c6a694.png)


Запустите образ еще раз, но на этот раз создайте интерактивную оболочку.

```docker
docker run -it --rm greeting /bin/bash
```

![image](https://user-images.githubusercontent.com/79700810/197198338-7eb62ee7-8d29-4d10-93c5-a0d9ea82458c.png)


Из интерактивной оболочки вы можете копаться внутри образа контейнера. Вы увидите, что он содержит полную базовую среду операционной системы Fedora.

Когда вы закончите, выключите контейнер, выполнив:

```
exit
```

### Системные пакеты


Базовые образы для дистрибутивов Linux минимальны, и в них будут отсутствовать различные пакеты, к которым вы, возможно, привыкли.


Хотя вам строго необходимо установить только дополнительные системные пакеты, необходимые вашему приложению для запуска, рекомендуется включить пакеты для инструментов, которые могут вам понадобиться при отладке работы вашего приложения при работе в контейнере.


Измените местоположение на подкаталог 

```
mkdir /appHelloFedoraDockerfile
chmod +x -R /appHelloFedoraDockerfile
```

![image](https://user-images.githubusercontent.com/79700810/197198917-ed7636e1-e35d-4888-8733-230eb9fffc99.png)



```
FROM fedora:35
RUN dnf install -y --setopt=tsflags=nodocs findutils procps which && \
    dnf clean -y --enablerepo='*' all
COPY hello goodbye /
CMD [ "/hello" ]
```

На этот раз вы должны увидеть:

![image](https://user-images.githubusercontent.com/79700810/197199281-d2d81fb0-66ad-4440-9fc5-f7d11b6bb825.png)



Инструкция RUN позволяет запустить команду в контексте контейнера, используемого для создания образа. В этом случае мы используем менеджер пакетов dnf для Fedora, чтобы установить findutils, procps и какие пакеты.


Хотя наличие базовых утилит UNIX полезно, вам не нужно иметь для них файлы документации. Если менеджер пакетов используемого вами дистрибутива Linux поддерживает это, исключите установку файлов документации. Это то, что делает параметр --setopt=tsflags=nodocs при запуске установки dnf.





Примечание: данные файлы должны быть созданные в этой директории и назначены права


```
cat > hello << EOF
#!/bin/sh
echo "hello"
EOF

cat > goodbye << EOF
#!/bin/sh
echo "goodbye"
EOF

chmod +x -R /appHelloFedoraPackages

ls
```


![image](https://user-images.githubusercontent.com/79700810/197200192-6fa7ae4c-a2cc-4595-a431-71b09c1587df.png)


Создайте образ, запустив:


```docker
docker build -t greeting .
```


![image](https://user-images.githubusercontent.com/79700810/197200708-05a0e710-79a3-4a38-9ed7-5b7da3319e34.png)


Перечислите слои созданного образа контейнера:

```docker
docker history greeting
```


![image](https://user-images.githubusercontent.com/79700810/197200950-5f1ac365-804a-4652-b9bb-a1c59e896096.png)


Вы увидите, что инструкция RUN отображается в образе контейнера как отдельный слой.


Вы можете включить в Dockerfile столько инструкций RUN, сколько хотите, но помните, что каждая из них приведет к созданию отдельного слоя, а удаление временных файлов в новой инструкции RUN, которые были созданы на предыдущем уровне, фактически не восстанавливает место, которое они занимают. использовал.


Вот почему в приведенном выше примере мы объединяем две команды в одной инструкции RUN. То есть команда dnf clean запускается как часть той же инструкции с использованием && в команде. Это гарантирует, что любой кеш, который заполняется dnf, но не требуется во время выполнения, удаляется до фиксации уровня, что уменьшает ненужное раздувание размера образа контейнера.


Когда мы добавили эту команду RUN, вы, возможно, также заметили, что мы не добавили ее в конец Dockerfile, а вместо этого вставили ее в начало.


Этот порядок был выбран, чтобы использовать преимущества кэширования при выполнении сборок. Чтобы проиллюстрировать, как работает кэширование, запустите:

```
touch hello
```

![image](https://user-images.githubusercontent.com/79700810/197202417-befec488-60d2-4f5a-9ee0-b2db1deda156.png)


и снова запустите сборку.


```docker
docker build -t greeting .
```

Вы должны увидеть вывод, похожий на:

![image](https://user-images.githubusercontent.com/79700810/197202603-f9626d6a-fde8-42ed-baaf-c22130742a1c.png)



Обратите особое внимание, и вы увидите, что команда, определенная инструкцией RUN, на этот раз не была выполнена, а вместо этого была использована кэшированная копия этого слоя. Это потому, что ничего не изменилось ни в инструкции, ни в базовых слоях.


Напротив, инструкция COPY и последующие инструкции обрабатывались снова. Это связано с тем, что мы обновили время модификации в файле сценария приветствия. Сборка достаточно умна, чтобы знать, что, поскольку файл сценария был обновлен, необходимо включить новую копию в образ контейнера. Последующие инструкции также должны были быть обработаны повторно, потому что предыдущие слои, на которых они основывались, изменились.




Из-за того, как кэширование работает для слоев при выполнении последующих сборок, обычной практикой является включение в Dockerfile инструкций, которые редко меняются ранее. Установка системных пакетов — один из лучших примеров этого.

Напротив, инструкции, относящиеся к пользовательскому приложению, будут включены в Dockerfile позже. Таким образом, при внесении изменений в ваше приложение вам нужно будет только пересобрать соответствующие ему слои, и вам не нужно каждый раз переустанавливать системные пакеты. Это ускорит ваши сборки.




### Обмен изображениями


После того, как вы создали свой собственный образ контейнера, вам понадобится способ его распространения, если вам нужно запустить его на другой хост-системе.

Обычный способ распространять образы контейнеров — помещать их в реестр образов. После того, как они помещены в реестр образов, их можно перенести на другие хосты и запустить. Для этого вы можете использовать общедоступные реестры образов, такие как Docker Hub и Quay.io, или вы можете использовать свой собственный частный реестр образов.


Чтобы поместить образ в реестр образов, сначала необходимо войти в этот реестр образов.

В этой рабочей среде у вас есть собственный частный реестр образов, в который вы уже вошли. Если бы вам нужно было сделать это самостоятельно, вы бы использовали команду входа в систему docker, указав расположение реестра образов. Затем вам будет предложено ввести учетные данные для входа.

Следующим шагом вам нужно пометить образ контейнера именем, которое включает в себя имя реестра образов.

Имя вашего изображения на этом этапе — greeting, поэтому, чтобы пометить его именем, включающим имя реестра образов, вам нужно запустить:


```docker
docker tag greeting:latest registry-educates-labs-w04-s031.tdc-prod-4f90164.tanzu-labs.esp.vmware.com/greeting:latest
```

![image](https://user-images.githubusercontent.com/79700810/197204498-5d6b1573-00e1-4a86-82d9-8940a5356b2d.png)


Чтобы поместить образ в реестр образов, запустите:


```docker
docker push registry-educates-labs-w04-s031.tdc-prod-4f90164.tanzu-labs.esp.vmware.com/greeting:latest
```

![image](https://user-images.githubusercontent.com/79700810/197204685-a1ae3fa8-5603-41ed-9c77-4b5aee7f2bc6.png)



Команда определяет, в какой реестр изображений его отправить, из добавленного вами тега, который включает имя реестра.

Любой, у кого есть соответствующий доступ к реестру образов, теперь может перенести его на другой хост, выполнив:


```docker
docker pull registry-educates-labs-w04-s031.tdc-prod-4f90164.tanzu-labs.esp.vmware.com/greeting:latest
```


!!!!!!!

### Создание директориии и права доступа

```
mkdir /home/user/docker
chmod -R 777 /home/user/docker/
```



### Установка VS Code WSL



![image](https://user-images.githubusercontent.com/79700810/197140549-3e42f1ca-dfaa-498d-ab99-4eecd9c8f3a2.png)


![image](https://user-images.githubusercontent.com/79700810/197140946-f0c3137e-78c4-42a0-8b32-6693fa592d67.png)


![image](https://user-images.githubusercontent.com/79700810/197141003-aebc5100-be7c-4078-970d-dd4d6f3f9d46.png)



hello.py

from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"



Dockerfile

# syntax=docker/dockerfile:1
FROM ubuntu:22.04

# install app dependencies
RUN apt-get update && apt-get install -y python3 python3-pip
RUN pip install flask==2.1.*

# install app
COPY hello.py /

# final configuration
ENV FLASK_APP=hello
EXPOSE 8000
CMD flask run --host 0.0.0.0 --port 8000


docker build -t hello:latest .


docker run --name hello -p 8000:8000 -d hello:latest



